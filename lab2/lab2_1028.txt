¬ данной программе мы используем два массива, первый массив хранит в себе уровень звезды по индексу, а второй ответы дл€ вывода, сначала, в цикле , мы записываем все координаты (x, y), по мере записи мы обрабатываем x(предварительно  инкрементиру€ ), далее в цикле обращаемс€ в функцию get, котора€ возвращает уровень звезды, обраща€сь к массиву по индексу get(x) мы инкрементируем значение в данном индексе (тем самым повыша€ кол-во звезд на данном уровне) затем мы вызываем функцию add, котора€ повышает уровень звезд, которые больше текущий, на единицу. 
ќсновной смысл алгоритма заключаетс€ в том, что обраща€сь к X в массиве дл€ хранени€ уровней и заполн€€ все то, что больше текущего значени€ единицами,а меньше записыва€ суммой в возвращаемую переменную, мы получаем уровень звезды по индексу. 
»терации же мы реализуем с помощью повышени€/уменьшени€ младшего бита, то есть например младший бит числа 6, равен двум. 
ѕриведем пример: 

¬озьмем 3 звезды: 
4 1 
8 3 
5 5 
Ќа первой итерации мы получим arr[0]++(массив еще не был затронут), это значит, что данна€ звезда имеет уровень 0. ƒалее мы заполним все что правее данного x, [5,6,8,16,32...,16384]. 
Ќа второй итерации мы получим arr[1]++, т.к. в функции get(x) мы отнимали младший бит в цикле от x(9, 8, 0), а так как индекс 8 от массива уже равен 1, то arr[1], далее вызовем функции add. 
Ќа третьей итерации мы получим arr[1]++(по тому же принципу) 
¬ итоге мы получаем ar[0]++, arr[1]++, ar[1]++, который соответствует выводу 
lvl 0 is 1 
lvl 1 is 2 
lvl 2 is 0